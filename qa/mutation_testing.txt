TODO:
- Text:
	- https://habr.com/company/oleg-bunin/blog/421141/
	- http://artkoshelev.github.io/posts/why-you-dont-need-mutation-testing
- Videos:
	- https://www.youtube.com/watch?v=9yG1c9Crnbk
	- https://www.youtube.com/watch?v=ChdLToGtm2s
	- https://www.youtube.com/watch?v=UIgzhoY1oAE
	- https://www.youtube.com/watch?v=ta5LiNvwWxM
	- https://www.youtube.com/watch?v=uC_8l69ArXs
	- https://www.youtube.com/watch?v=-1820HwCJUA (рус)
	- https://www.youtube.com/watch?v=gGZ-5uHYAi4 (рус)
	- https://www.youtube.com/watch?v=U8pKSQxaZLQ (рус)


- Test Pyramid
- Test Coverage - useless?
	- branch coverage is more or less the same?
	- types of coverage
-  "Quis custodiet ipsos custodes?" ["Who watches the watchmen?"]
- Goals:
	- identify weakly tested pieces of code
	- identify weak tests
	- get rid of useless tests?
- Comparison:
	- MT vs Fault injection
	- MT vs Static analysis
		- Access Modifier Change?
- Terminology
	- Mutation Operator = Mutator
		- first order mutants (simple mutants)
		- high order mutants (complex mutants)
	- Mutant
		- Simple vs Complex
		- Killed Mutant (RIP model):
			- A test must reach the mutated statement.
			- Test input data should infect the program state by causing different program states for the mutant and the original program.
			- The incorrect program state must propagate to the program's output and be checked by the test.
		- Survived / Escaped Mutant
		- Timeout Mutant (++ / -- in loop)
		- Error (Exception, OOM, non valid code)
		- Equivalent mutant
			- dead code - identified by code coverage tools
	- MSI mutation score = number of mutants killed / total number of mutants
	- MCC (https://habr.com/post/334394/)
- Problems:
	- high computational cost
		- reduce number of mutants
			- Mutant Sampling - random subset of all mutants
			- Selective Mutation - certain types of mutators to generate mutants
			- Mutant Clustering - includes analysis of tests to identify subset
			- Higher Order Mutation - combines mutators (FOM * x = HOM) to make a single one with the same possibility to tail as a set of others
		- optimize execution process
			- break the program by modules
			- Bytecode Translation technique
			- parallel runs
			- etc
	- equivalent mutant problem = human effort
		- suggest (SEM)
		- detect (DEM)
		- avoid (AEMG)
	- human oracle problem - more tests
- Practical part:
	- Java (active):
		- pitest: https://github.com/hcoles/pitest
			- 
	- Javascript/Typescript (active):
		- Stryker: https://github.com/stryker-mutator/stryker
			- Issues:
				- async tests? -> increate timeoutFactor
- When do we need to add mutation testing?
	- New tests
	- Who uses mutation testing?
- Do not test:
	- file operations
	- 
	
	
Useful Links:
- https://en.wikipedia.org/wiki/Mutation_testing
- http://crestweb.cs.ucl.ac.uk/resources/mutation_testing_repository/
- https://github.com/scoban/mutation-analysis